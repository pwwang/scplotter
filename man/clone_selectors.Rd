% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clonalutils.R
\name{.get_data}
\alias{.get_data}
\alias{.return_what}
\alias{top}
\alias{sel}
\alias{uniq}
\alias{shared}
\alias{gt}
\alias{ge}
\alias{lt}
\alias{le}
\alias{eq}
\alias{ne}
\alias{and}
\alias{or}
\title{Helper functions to select clones based on various criteria}
\usage{
.get_data(data)

.return_what(data, id, return_all)

top(
  n,
  groups = NULL,
  data = NULL,
  order = NULL,
  id = "CTaa",
  return_all = NULL
)

sel(expr, groups = NULL, data = NULL, id = "CTaa", return_all = NULL)

uniq(
  group1,
  group2,
  ...,
  groups = NULL,
  data = NULL,
  id = "CTaa",
  return_all = NULL
)

shared(
  group1,
  group2,
  ...,
  groups = NULL,
  data = NULL,
  id = "CTaa",
  return_all = NULL
)

gt(
  group1,
  group2,
  include_zeros = TRUE,
  groups = NULL,
  data = NULL,
  id = "CTaa",
  return_all = NULL
)

ge(
  group1,
  group2,
  include_zeros = TRUE,
  groups = NULL,
  data = NULL,
  id = "CTaa",
  return_all = NULL
)

lt(
  group1,
  group2,
  include_zeros = TRUE,
  groups = NULL,
  data = NULL,
  id = "CTaa",
  return_all = NULL
)

le(
  group1,
  group2,
  include_zeros = TRUE,
  groups = NULL,
  data = NULL,
  id = "CTaa",
  return_all = NULL
)

eq(group1, group2, groups = NULL, data = NULL, id = "CTaa", return_all = NULL)

ne(
  group1,
  group2,
  include_zeros = TRUE,
  groups = NULL,
  data = NULL,
  id = "CTaa",
  return_all = NULL
)

and(x, y)

or(x, y)
}
\arguments{
\item{data}{The data frame containing clone information. Default is NULL. If NULL, it will get data from parent.frame.
A typical \code{data} should have a column named \code{CTaa} and other columns for the groupings.
Supposingly it should be a grouped data frame with the grouping columns.
Under each grouping column, the value should be the size of the clone.
By default, the data is assumed to be in the parent frame.}

\item{id}{The column name that contains the clone ID. Default is "CTaa".}

\item{return_all}{If TRUE, the function returns a vector with the same length as the data, with CTaa values for selected clones and NA for others.
If FALSE, it returns a subset data frame with only the selected clones.
Default is NULL, which will be determined based on the data. If the function is used in a context of dplyr verbs, it defaults to TRUE.
Otherwise, it defaults to FALSE.}

\item{n}{The number of top clones to select or the threshold size.}

\item{groups}{The column names in the meta data to group the cells.
By default, it is assumed \code{facet_by} and \code{split_by} to be in the parent frame.}

\item{expr}{The expression (in characters) to filter the clones
(e.g. "group1 > group2" to select clones where group1 is larger than group2).}

\item{group1}{The first group to compare.}

\item{group2}{The second group to compare.}

\item{...}{More groups to compare.}

\item{include_zeros}{Whether to include clones with zero size in the comparison.
If TRUE, in a comparison (s1 > s2) for a clone to be selected, both s1 and s2 must be greater than 0.
If FALSE, only the first group must be greater than the second group.}

\item{x}{The first vector to compare in logical operations (and/or).}

\item{y}{The second vector to compare in logical operations (and/or).}
}
\value{
A vector of CTaas or a data frame with the selected clones based on the criteria.
}
\description{
These helper functions allow for the selection of clones based on various criteria such as size, group comparison, and existence in specific groups.
}
\examples{
data <- data.frame(
    CTaa = 1:10,
    group1 = c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9),
    group2 = c(7, 3, 8, 2, 1, 5, 9, 4, 6, 0),
    groups = c("A", "A", "A", "A", "B", "B", "B", "B", "B", "B")
)
data <- data[order(data$group1 + data$group2, decreasing = TRUE), ]
scplotter:::top(3)
scplotter:::top(3, groups = "groups")
scplotter:::sel(group1 == 0 | group2 == 0)
scplotter:::uniq(group1, group2)
scplotter:::shared(group1, group2)
scplotter:::gt(group1, group2)
scplotter:::lt(group1, group2)
scplotter:::le(group1, group2)
scplotter:::lt(group1, group2, include_zeros = FALSE)
scplotter:::eq(group1, group2)
scplotter:::ne(group1, group2)

# Use them in a dplyr pipeline
dplyr::mutate(data, Top3 = scplotter:::top(3))
dplyr::mutate(data, Top3 = scplotter:::top(3, groups = "groups"))
dplyr::mutate(data, Unique = scplotter:::sel(group1 == 0 | group2 == 0))
dplyr::mutate(data, UniqueInG1 = scplotter:::uniq(group1, group2))
dplyr::mutate(data, Shared = scplotter:::shared(group1, group2))
dplyr::mutate(data, Greater = scplotter:::gt(group1, group2))
dplyr::mutate(data, Less = scplotter:::lt(group1, group2))
dplyr::mutate(data, LessEqual = scplotter:::le(group1, group2))
dplyr::mutate(data, GreaterEqual = scplotter:::ge(group1, group2))
dplyr::mutate(data, Equal = scplotter:::eq(group1, group2))
dplyr::mutate(data, NotEqual = scplotter:::ne(group1, group2))

# Compond expressions
dplyr::mutate(data,
  Top3OrEqual = scplotter:::or(scplotter:::top(3), scplotter:::eq(group1, group2)))
dplyr::mutate(data,
  SharedAndGreater = scplotter:::and(
     scplotter:::shared(group1, group2), scplotter:::gt(group1, group2)))
}
\keyword{internal}
